<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>스도쿠 · 블랙 테마</title>
  <style>
    :root{
      --bg:#000000;          /* 전체 배경 (블랙) */
      --ui:#FFFFFF;          /* UI 버튼 등 (화이트) */
      --cell:#000000;        /* 칸 내부 (블랙) */
      --num:#BFBFBF;         /* 숫자 (밝은 회색) */
      --line:#BFBFBF;        /* 격자선 (밝은 회색) */
      --accent:#9e9e9e;      /* 포커스 라인 (회색) */
      --error:#ff4d4f;       /* 에러 표시 */
      --ok:#52c41a;          /* 성공 표시 */
    }

    *{box-sizing:border-box}
    *{-webkit-tap-highlight-color: transparent}
    button, select, .cell{touch-action: manipulation}
    html,body{height:100%; -webkit-text-size-adjust:100%;}
    body{
      margin:0; background:var(--bg); color:var(--ui);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, Helvetica Neue, Arial, "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
      display:flex; align-items:center; justify-content:center;
    }

    h1{ margin:0 0 12px; font-weight:700; letter-spacing:.3px; }

    .app{ width:min(95vw, 820px); padding:18px; margin:auto; }
    .toolbar{ display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin-bottom:14px; }
    .toolbar label{ font-size:14px; opacity:.9; }

    select, button{
      -webkit-appearance:none; appearance:none;
      background:var(--ui); color:#000; border:1px solid #000; border-radius:12px;
      padding:12px 16px; font-size:16px; font-weight:700; cursor:pointer; outline:none;
      min-height:44px; /* iOS 권장 터치 타깃 */
    }
    select{ padding-right:28px }
    button:disabled{ opacity:.5; cursor:not-allowed }

    .status{ min-height:22px; margin-left:auto; font-size:13px; opacity:.9; }
    .status.error{ color:var(--error); }
    .status.ok{ color:var(--ok); }

    .board-wrap{ position:relative; }
    .board{
      width:min(92vw, 90vmin, 640px); height:min(92vw, 90vmin, 640px);
      background:var(--bg); border:3px solid var(--line); border-radius:16px;
      display:grid; grid-template-columns:repeat(9,1fr); grid-template-rows:repeat(9,1fr);
      overflow:hidden;
    }

    .cell{
      position:relative; border:1px solid var(--line); display:flex; align-items:center; justify-content:center;
      background:var(--cell);
    }

    /* 굵은 3x3 경계선 */
    .cell[r="0"], .cell[r="3"], .cell[r="6"]{ border-top-width:3px }
    .cell[c="0"], .cell[c="3"], .cell[c="6"]{ border-left-width:3px }
    .cell[r="8"]{ border-bottom-width:3px }
    .cell[c="8"]{ border-right-width:3px }

    input.sudoku{
      width:100%; height:100%;
      border:none; outline:none; background:transparent; text-align:center;
      font-size: clamp(20px, 7.2vmin, 44px); font-weight:800; color:var(--num);
      caret-color:#fff; -webkit-text-size-adjust:100%;
    }
    input.sudoku:disabled{ cursor:default }

    /* 선택 강조 */
    .cell.selected{ box-shadow: inset 0 0 0 2px var(--accent); }

    /* 힌트 모드 안내 오버레이 */
    .hint-banner{
      position:absolute; left:50%; top:-10px; transform:translate(-50%, -100%);
      background:var(--ui); color:#000; padding:8px 12px; border-radius:999px;
      border:1px solid #000; font-size:13px; font-weight:700; white-space:nowrap;
      display:none; z-index:10;
    }
    .board-wrap.hint .hint-banner{ display:block }

    @media (max-width: 480px){
      .app{padding:14px}
      h1{font-size:20px}
    }

    .footer{display:none}
  </style>
</head>
<body>
  <div class="app">
    <h1>스도쿠</h1>
    <div class="toolbar">
      <label>난이도
        <select id="difficulty" aria-label="난이도">
          <option value="easy">하 (쉬움)</option>
          <option value="medium" selected>중 (보통)</option>
          <option value="hard">상 (어려움)</option>
        </select>
      </label>
      <button id="newGame">새 게임</button>
      <button id="hintBtn">힌트 (3)</button>
      <div class="status" id="status" aria-live="polite"></div>
    </div>

    <div class="board-wrap" id="boardWrap">
      <div class="hint-banner">힌트 사용 중: 빈 칸을 클릭하세요</div>
      <div class="board" id="board" role="grid" aria-label="스도쿠 보드"></div>
    </div>
  </div>

  <script>
  (function(){
    'use strict';

    // ===== 상수/검증 =====
    const ROWS = 9, COLS = 9, CELLS = ROWS*COLS;
    if(!Number.isInteger(ROWS) || !Number.isInteger(COLS) || ROWS<=0 || COLS<=0){
      throw new RangeError('Invalid grid size: ROWS and COLS must be positive integers');
    }

    // ===== 전역 상태 =====
    const boardEl = document.getElementById('board');
    const boardWrapEl = document.getElementById('boardWrap');
    const diffEl = document.getElementById('difficulty');
    const newBtn = document.getElementById('newGame');
    const hintBtn = document.getElementById('hintBtn');
    const statusEl = document.getElementById('status');

    let solution = createEmptyGrid(); // 9x9 정답
    let puzzle   = createEmptyGrid(); // 9x9 퍼즐 (0=빈칸)
    let selected = null;              // 현재 선택된 input 요소
    let hintsLeft = 3;                // 힌트 남은 횟수
    let hintMode = false;             // 힌트 클릭 후 셀 선택 대기

    const DIFFICULTY_CLUES = {
      easy:   [36, 45],   // 하
      medium: [32, 35],   // 중
      hard:   [28, 31]    // 상
    };

    // ===== 유틸 =====
    function setStatus(msg, cls){
      statusEl.textContent = msg || '';
      statusEl.classList.remove('error','ok');
      if(cls) statusEl.classList.add(cls);
    }

    function range(n){
      // 안전한 range: length 인자로 인한 RangeError 예방
      n = Number(n);
      if(!Number.isInteger(n) || n < 0 || !Number.isFinite(n)) throw new RangeError('range() expects non-negative integer');
      const out = [];
      for(let i=0;i<n;i++) out.push(i);
      return out;
    }

    function createEmptyGrid(){
      // Array(9) 대신 push 루프 사용 (Invalid array length 방지)
      const g = [];
      for(let r=0;r<ROWS;r++){
        const row = [];
        for(let c=0;c<COLS;c++) row.push(0);
        g.push(row);
      }
      return g;
    }

    function deepCopy(grid){
      const g = [];
      for(let r=0;r<ROWS;r++){
        const row = [];
        for(let c=0;c<COLS;c++) row.push(grid[r][c]);
        g.push(row);
      }
      return g;
    }

    function shuffle(arr){
      // 방어: 배열이 아니거나 length 이상치일 때 예외 방지
      if(!Array.isArray(arr)) return arr;
      for(let i=arr.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        const t = arr[i]; arr[i]=arr[j]; arr[j]=t;
      }
      return arr;
    }

    function randInt(min,max){ // inclusive
      min = Math.ceil(min); max = Math.floor(max);
      if(!Number.isFinite(min) || !Number.isFinite(max) || max < min) throw new RangeError('randInt() invalid bounds');
      return Math.floor(Math.random()*(max-min+1))+min;
    }

    // ===== 스도쿠 검증 / 후보 =====
    function isSafe(board, r, c, n){
      for(let i=0;i<COLS;i++) if(board[r][i]===n) return false;
      for(let i=0;i<ROWS;i++) if(board[i][c]===n) return false;
      const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
      for(let i=0;i<3;i++) for(let j=0;j<3;j++) if(board[br+i][bc+j]===n) return false;
      return true;
    }

    function getCandidates(board, r, c){
      if(board[r][c]!==0) return [];
      const cand = [];
      for(let n=1;n<=9;n++) if(isSafe(board,r,c,n)) cand.push(n);
      return cand;
    }
    function findBestCell(board){
      let best=null, bestCount=10;
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          if(board[r][c]===0){
            const cand = getCandidates(board,r,c);
            const k = cand.length;
            if(k===0) return {r, c, cand};
            if(k<bestCount){ best={r,c,cand}; bestCount=k; if(k===1) return best; }
          }
        }
      }
      return best; // null => 가득 참
    }

    // ===== 해답/해 카운트 (MRV 적용) =====
    function fillBoardRandom(board){
      const cell = findBestCell(board);
      if(!cell) return true; // 다 채움
      const {r,c,cand} = cell;
      if(cand.length===0) return false;
      shuffle(cand);
      for(const n of cand){
        board[r][c]=n;
        if(fillBoardRandom(board)) return true;
        board[r][c]=0;
      }
      return false;
    }

    function countSolutions(board, limit=2){
      let count = 0;
      function backtrack(){
        if(count>=limit) return;
        const cell = findBestCell(board);
        if(!cell){ count++; return; }
        const {r,c,cand} = cell;
        if(cand.length===0) return; // 막힘
        for(const n of cand){
          board[r][c]=n; backtrack(); board[r][c]=0;
          if(count>=limit) return;
        }
      }
      backtrack();
      return count;
    }

    // ===== 퍼즐 생성 (타임아웃 포함) =====
    function generatePuzzle(difficulty, timeoutMs=2500){
      const deadline = (typeof performance!=='undefined' && performance.now) ? performance.now()+timeoutMs : Date.now()+timeoutMs;
      while(((typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now()) < deadline){
        const sol = createEmptyGrid();
        if(!fillBoardRandom(sol)) continue;

        const pair = DIFFICULTY_CLUES[difficulty] || DIFFICULTY_CLUES.medium;
        const minClue = pair[0], maxClue = pair[1];
        const targetClues = randInt(minClue, maxClue);

        const puz = deepCopy(sol);
        let clues = ROWS*COLS; // 81
        const order = shuffle(range(CELLS));
        let ok = true;
        for(const idx of order){
          if(clues<=targetClues) break;
          const r = Math.floor(idx/COLS), c = idx%COLS;
          if(puz[r][c]===0) continue;
          const keep = puz[r][c];
          puz[r][c]=0;
          const tmp = deepCopy(puz);
          if(countSolutions(tmp, 2)!==1){
            puz[r][c]=keep; // 유일성 깨지면 복구
          }else{
            clues--;
          }
          const now = (typeof performance!=='undefined' && performance.now) ? performance.now() : Date.now();
          if(now>deadline){ ok=false; break; }
        }
        if(ok) return {solution: sol, puzzle: puz};
      }
      return null; // 시간 초과
    }

    // ===== UI 렌더링 =====
    function buildBoard(){
      boardEl.innerHTML = '';
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.setAttribute('r', r);
          cell.setAttribute('c', c);

          const input = document.createElement('input');
          input.type='text';
          input.inputMode='numeric';
          input.pattern='[1-9]*';
          input.maxLength=1;
          input.className='sudoku';
          input.dataset.r = r;
          input.dataset.c = c;

          input.addEventListener('focus', ()=> selectCell(cell, input));
          input.addEventListener('click', ()=> selectCell(cell, input));

          input.addEventListener('keydown', (e)=>{
            if(input.disabled) return;
            const k = e.key;
            if(k>='1' && k<='9'){
              input.value = k; puzzle[r][c] = Number(k); e.preventDefault();
            }else if(k==='Backspace' || k==='Delete' || k==='0'){
              input.value=''; puzzle[r][c]=0; e.preventDefault();
            }else if(k==='ArrowUp' || k==='ArrowDown' || k==='ArrowLeft' || k==='ArrowRight'){
              moveSelection(r,c,k); e.preventDefault();
            }else if(k.length===1){ e.preventDefault(); }
          });

          cell.addEventListener('click', ()=>{ if(hintMode){ applyHintTo(r,c); } });

          cell.appendChild(input);
          boardEl.appendChild(cell);
        }
      }
    }

    function renderBoard(){
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const idx = r*COLS+c;
          const cell = boardEl.children[idx];
          const input = cell.querySelector('input');
          const val = puzzle[r][c];
          const given = originPuzzle[r][c]!==0;
          input.value = val? String(val): '';
          input.disabled = given;
        }
      }
    }

    function clearSelection(){
      const prev = document.querySelector('.cell.selected');
      if(prev) prev.classList.remove('selected');
    }
    function selectCell(cell, input){
      clearSelection(); cell.classList.add('selected'); selected = input;
    }
    function moveSelection(r,c,key){
      const delta = { ArrowUp:[-1,0], ArrowDown:[1,0], ArrowLeft:[0,-1], ArrowRight:[0,1] }[key];
      const nr = Math.max(0, Math.min(ROWS-1, r+delta[0]));
      const nc = Math.max(0, Math.min(COLS-1, c+delta[1]));
      const idx = nr*COLS+nc;
      const cell = boardEl.children[idx];
      const input = cell.querySelector('input');
      input.focus();
    }

    function setHintMode(on){
      hintMode = on; 
      boardWrapEl.classList.toggle('hint', on);
      hintBtn.disabled = (hintsLeft<=0 && !on);
      setStatus(on? '힌트 사용 중: 빈 칸을 클릭하세요' : '');
    }

    function applyHintTo(r,c){
      const idx = r*COLS+c;
      const cell = boardEl.children[idx];
      const input = cell.querySelector('input');
      if(originPuzzle[r][c]!==0){ setStatus('처음부터 채워진 칸은 힌트를 사용할 수 없습니다.', 'error'); return; }
      const correct = solution[r][c];
      if(puzzle[r][c]!==correct){ puzzle[r][c]=correct; input.value = String(correct); }
      hintsLeft = Math.max(0, hintsLeft-1);
      hintBtn.textContent = `힌트 (${hintsLeft})`;
      if(hintsLeft<=0){ setHintMode(false); hintBtn.disabled = true; setStatus('힌트를 모두 사용했습니다.'); }
    }

    // ===== 게임 수명주기 =====
    let originPuzzle = createEmptyGrid();

    function newGame(){
      const difficulty = diffEl.value;
      setStatus('새 퍼즐 생성 중…');
      hintBtn.disabled = true;
      setTimeout(()=>{
        try{
          const gen = generatePuzzle(difficulty, 3000);
          if(!gen){
            setStatus('생성 시간이 길어 재시도해주세요.', 'error');
            hintBtn.disabled = false;
            return;
          }
          solution = gen.solution;
          puzzle   = deepCopy(gen.puzzle);
          originPuzzle = deepCopy(gen.puzzle);
          hintsLeft = 3; hintBtn.textContent = '힌트 (3)'; hintBtn.disabled = false;
          setHintMode(false);
          buildBoard();
          renderBoard();
          setStatus('');
          const first = boardEl.querySelector('input:not(:disabled)');
          if(first) first.focus();
        }catch(err){
          console.error(err);
          setStatus('에러: '+(err && err.message ? err.message : err), 'error');
          hintBtn.disabled = false;
        }
      }, 0);
    }

    newBtn.addEventListener('click', newGame);
    diffEl.addEventListener('change', newGame);
    hintBtn.addEventListener('click', ()=>{
      if(hintsLeft<=0){ setStatus('힌트를 모두 사용했습니다.'); return; }
      setHintMode(!hintMode);
    });
    document.addEventListener('click', (e)=>{ if(!boardEl.contains(e.target)) clearSelection(); });

    // ===== 전역 에러 핸들러 =====
    window.addEventListener('error', (e)=>{ setStatus('에러: '+(e && e.message ? e.message : '알 수 없는 오류'), 'error'); });

    // ===== 테스트 (URL에 ?test=1 붙이면 실행) =====
    function runTests(){
      const logs = [];
      function t(name, fn){
        try{ fn(); logs.push('✅ '+name); }
        catch(e){ logs.push('❌ '+name+' -> '+e.message); throw e; }
      }
      const assert = (cond, msg)=>{ if(!cond) throw new Error(msg||'assert'); };

      t('createEmptyGrid는 9x9 0으로 채워진 배열을 만든다', ()=>{
        const g = createEmptyGrid();
        assert(Array.isArray(g) && g.length===ROWS, '행 길이');
        for(let r=0;r<ROWS;r++) assert(Array.isArray(g[r]) && g[r].length===COLS, '열 길이');
        for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) assert(g[r][c]===0, '초기값 0');
      });

      t('fillBoardRandom는 완전한 해답을 만든다', ()=>{
        const g = createEmptyGrid();
        const ok = fillBoardRandom(g);
        assert(ok, '채우기 성공');
        for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) assert(g[r][c]>=1 && g[r][c]<=9, '1..9');
      });

      t('generatePuzzle는 각 난이도에서 퍼즐을 만든다', ()=>{
        for(const d of ['easy','medium','hard']){
          const gen = generatePuzzle(d, 2000);
          assert(gen!==null, d+' 생성됨');
          const tmp = deepCopy(gen.puzzle);
          assert(countSolutions(tmp,2)===1, d+' 유일해');
        }
      });

      console.log('\n[테스트 결과]\n'+logs.join('\n'));
      setStatus('테스트 완료', 'ok');
    }

    // 초기 실행
    buildBoard();
    if(location.search.includes('test=1')){ try{ runTests(); }catch(_){} }
    newGame();

  })();
  </script>
</body>
</html>
