<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>스도쿠 · 블랙 테마</title>
  <style>
    :root{
      --bg:#000000;   /* 전체 배경 */
      --ui:#FFFFFF;   /* 버튼/패널 */
      --cell:#000000; /* 칸 내부 */
      --num:#BFBFBF;  /* 숫자 */
      --line:#BFBFBF; /* 격자선 */
      --accent:#9e9e9e;
      --error:#ff4d4f;
      --ok:#52c41a;
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html,body{ height:100%; -webkit-text-size-adjust:100%; }
    body{
      margin:0; background:var(--bg); color:var(--ui);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, Helvetica Neue, Arial, "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
      display:flex; align-items:center; justify-content:center;
    }

    .app{ width:min(95vw, 820px); padding:18px; margin:auto; }
    h1{ margin:0 0 12px; font-weight:700; letter-spacing:.3px; }

    .toolbar{ display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin-bottom:14px; }
    .toolbar label{ font-size:14px; opacity:.9; }

    select, button{
      -webkit-appearance:none; appearance:none;
      background:var(--ui); color:#000; border:1px solid #000; border-radius:12px;
      padding:12px 16px; font-size:16px; font-weight:700; cursor:pointer; outline:none;
      min-height:44px;
    }
    select{ padding-right:28px }
    button:disabled{ opacity:.5; cursor:not-allowed }

    .status{ min-height:22px; margin-left:auto; font-size:13px; opacity:.9; }
    .status.error{ color:var(--error); }
    .status.ok{ color:var(--ok); }

    .board-wrap{ position:relative; }
    /* ✅ 정사각 보드 + gap 선 + 오버레이로 3×3 굵은선 */
    .board{
      width:min(92vw, 90vmin, 640px);
      aspect-ratio:1/1;                /* 항상 정사각형 유지 */
      background:var(--line);           /* gap(1px) 색 */
      border:3px solid var(--line);
      border-radius:16px;
      display:grid; grid-template-columns:repeat(9,1fr); grid-template-rows:repeat(9,1fr);
      gap:1px;
      overflow:hidden;
      position:relative;
    }
    .cell{ background:var(--cell); display:flex; align-items:center; justify-content:center; }
    .board::after{
      content:""; position:absolute; inset:0; pointer-events:none; border-radius:inherit;
      /* 굵은 3x3 라인(세로/가로) */
      background:
        linear-gradient(to right,
          transparent calc(33.333% - 1.5px), var(--line) calc(33.333% - 1.5px),
          var(--line) calc(33.333% + 1.5px), transparent calc(33.333% + 1.5px),
          transparent calc(66.666% - 1.5px), var(--line) calc(66.666% - 1.5px),
          var(--line) calc(66.666% + 1.5px), transparent calc(66.666% + 1.5px)
        ),
        linear-gradient(to bottom,
          transparent calc(33.333% - 1.5px), var(--line) calc(33.333% - 1.5px),
          var(--line) calc(33.333% + 1.5px), transparent calc(33.333% + 1.5px),
          transparent calc(66.666% - 1.5px), var(--line) calc(66.666% - 1.5px),
          var(--line) calc(66.666% + 1.5px), transparent calc(66.666% + 1.5px)
        );
      background-repeat:no-repeat;
      background-size:100% 100%, 100% 100%;
    }

    input.sudoku{
      width:100%; height:100%;
      display:block; box-sizing:border-box;
      border:none; outline:none; background:transparent; text-align:center;
      -webkit-appearance:none; appearance:none;
      font-size: clamp(22px, 7.8vmin, 44px); font-weight:700; color:var(--num);
      line-height:1; padding:2px 0 3px; margin:0; caret-color:#fff;
    }
    input.sudoku:disabled{ cursor:default }

    .cell.selected{ box-shadow: inset 0 0 0 2px var(--accent); }

    .hint-banner{
      position:absolute; left:50%; top:-10px; transform:translate(-50%, -100%);
      background:var(--ui); color:#000; padding:8px 12px; border-radius:999px;
      border:1px solid #000; font-size:13px; font-weight:700; white-space:nowrap;
      display:none; z-index:10;
    }
    .board-wrap.hint .hint-banner{ display:block }

    @media (max-width: 480px){
      .app{padding:14px}
      h1{font-size:20px}
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>스도쿠</h1>
    <div class="toolbar">
      <label>난이도
        <select id="difficulty" aria-label="난이도">
          <option value="easy">하 (쉬움)</option>
          <option value="medium" selected>중 (보통)</option>
          <option value="hard">상 (어려움)</option>
        </select>
      </label>
      <button id="newGame">새 게임</button>
      <button id="hintBtn">힌트 (3)</button>
      <div class="status" id="status" aria-live="polite"></div>
    </div>

    <div class="board-wrap" id="boardWrap">
      <div class="hint-banner">힌트 사용 중: 빈 칸을 클릭하세요</div>
      <div class="board" id="board" role="grid" aria-label="스도쿠 보드"></div>
    </div>
  </div>

  <script>
  (function(){
    'use strict';

    /* ===== 상수 ===== */
    const ROWS = 9, COLS = 9, CELLS = ROWS*COLS;

    /* ===== 전역 상태 ===== */
    const boardEl = document.getElementById('board');
    const boardWrapEl = document.getElementById('boardWrap');
    const diffEl = document.getElementById('difficulty');
    const newBtn = document.getElementById('newGame');
    const hintBtn = document.getElementById('hintBtn');
    const statusEl = document.getElementById('status');

    let solution = createEmptyGrid(); // 9x9 정답
    let puzzle   = createEmptyGrid(); // 9x9 퍼즐 (0=빈칸)
    let selected = null;
    let hintsLeft = 3;
    let hintMode = false;

    const DIFFICULTY_CLUES = {
      easy:   [36, 45],
      medium: [32, 35],
      hard:   [28, 31]
    };

    /* ===== 유틸 ===== */
    function setStatus(msg, cls){
      statusEl.textContent = msg || '';
      statusEl.classList.remove('error','ok');
      if(cls) statusEl.classList.add(cls);
    }
    function range(n){ const out=[]; for(let i=0;i<n;i++) out.push(i); return out; }
    function createEmptyGrid(){
      const g = [];
      for(let r=0;r<ROWS;r++){ const row = []; for(let c=0;c<COLS;c++) row.push(0); g.push(row); }
      return g;
    }
    function deepCopy(grid){
      const g = [];
      for(let r=0;r<ROWS;r++){ const row = []; for(let c=0;c<COLS;c++) row.push(grid[r][c]); g.push(row); }
      return g;
    }
    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }
    function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

    /* ===== 스도쿠 로직 ===== */
    function isSafe(board, r, c, n){
      for(let i=0;i<COLS;i++) if(board[r][i]===n) return false;
      for(let i=0;i<ROWS;i++) if(board[i][c]===n) return false;
      const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
      for(let i=0;i<3;i++) for(let j=0;j<3;j++) if(board[br+i][bc+j]===n) return false;
      return true;
    }
    function getCandidates(board, r, c){
      if(board[r][c]!==0) return [];
      const cand = []; for(let n=1;n<=9;n++) if(isSafe(board,r,c,n)) cand.push(n);
      return cand;
    }
    function findBestCell(board){
      let best=null, bestCount=10;
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        if(board[r][c]===0){
          const cand=getCandidates(board,r,c), k=cand.length;
          if(k===0) return {r,c,cand};
          if(k<bestCount){ best={r,c,cand}; bestCount=k; if(k===1) return best; }
        }
      }
      return best; // null => 가득 참
    }
    function fillBoardRandom(board){
      const cell = findBestCell(board);
      if(!cell) return true;
      const {r,c,cand} = cell;
      if(cand.length===0) return false;
      shuffle(cand);
      for(const n of cand){ board[r][c]=n; if(fillBoardRandom(board)) return true; board[r][c]=0; }
      return false;
    }
    function countSolutions(board, limit=2){
      let count=0;
      (function backtrack(){
        if(count>=limit) return;
        const cell=findBestCell(board);
        if(!cell){ count++; return; }
        const {r,c,cand}=cell;
        if(cand.length===0) return;
        for(const n of cand){ board[r][c]=n; backtrack(); board[r][c]=0; if(count>=limit) return; }
      })();
      return count;
    }
    function generatePuzzle(difficulty, timeoutMs=2500){
      const deadline = (performance && performance.now? performance.now(): Date.now()) + timeoutMs;
      while((performance && performance.now? performance.now(): Date.now()) < deadline){
        const sol = createEmptyGrid(); if(!fillBoardRandom(sol)) continue;
        const [minClue,maxClue] = DIFFICULTY_CLUES[difficulty] || DIFFICULTY_CLUES.medium;
        const targetClues = randInt(minClue, maxClue);
        const puz = deepCopy(sol);
        let clues = ROWS*COLS;
        const order = shuffle(range(CELLS));
        let ok = true;
        for(const idx of order){
          if(clues<=targetClues) break;
          const r=Math.floor(idx/COLS), c=idx%COLS;
          if(puz[r][c]===0) continue;
          const keep=puz[r][c]; puz[r][c]=0;
          const tmp=deepCopy(puz);
          if(countSolutions(tmp,2)!==1){ puz[r][c]=keep; } else { clues--; }
          if((performance && performance.now? performance.now(): Date.now())>deadline){ ok=false; break; }
        }
        if(ok) return {solution: sol, puzzle: puz};
      }
      return null;
    }

    /* ===== UI ===== */
    function buildBoard(){
      boardEl.innerHTML='';
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        const cell=document.createElement('div'); cell.className='cell'; cell.setAttribute('r',r); cell.setAttribute('c',c);
        const input=document.createElement('input'); input.type='text'; input.inputMode='numeric'; input.pattern='[1-9]*'; input.maxLength=1; input.className='sudoku';
        input.dataset.r=r; input.dataset.c=c;
        input.addEventListener('focus', ()=> selectCell(cell,input));
        input.addEventListener('click', ()=> selectCell(cell,input));
        input.addEventListener('keydown', (e)=>{
          if(input.disabled) return;
          const k=e.key;
          if(k>='1'&&k<='9'){ input.value=k; puzzle[r][c]=Number(k); e.preventDefault(); }
          else if(k==='Backspace'||k==='Delete'||k==='0'){ input.value=''; puzzle[r][c]=0; e.preventDefault(); }
          else if(k.startsWith('Arrow')){ moveSelection(r,c,k); e.preventDefault(); }
          else if(k.length===1){ e.preventDefault(); }
        });
        cell.addEventListener('click', ()=>{ if(hintMode){ applyHintTo(r,c); } });
        cell.appendChild(input); boardEl.appendChild(cell);
      }
    }
    function renderBoard(){
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        const idx=r*COLS+c, cell=boardEl.children[idx], input=cell.querySelector('input');
        const val=puzzle[r][c], given=originPuzzle[r][c]!==0;
        input.value = val? String(val): ''; input.disabled = given;
      }
    }
    function clearSelection(){ const prev=document.querySelector('.cell.selected'); if(prev) prev.classList.remove('selected'); }
    function selectCell(cell,input){ clearSelection(); cell.classList.add('selected'); selected=input; }
    function moveSelection(r,c,key){
      const delta={ArrowUp:[-1,0],ArrowDown:[1,0],ArrowLeft:[0,-1],ArrowRight:[0,1]}[key];
      const nr=Math.max(0,Math.min(ROWS-1,r+delta[0])); const nc=Math.max(0,Math.min(COLS-1,c+delta[1]));
      const idx=nr*COLS+nc; const cell=boardEl.children[idx]; const input=cell.querySelector('input'); input.focus();
    }
    function setHintMode(on){ hintMode=on; boardWrapEl.classList.toggle('hint',on); hintBtn.disabled=(hintsLeft<=0 && !on); setStatus(on?'힌트 사용 중: 빈 칸을 클릭하세요':''); }
    function applyHintTo(r,c){
      const idx=r*COLS+c, cell=boardEl.children[idx], input=cell.querySelector('input');
      if(originPuzzle[r][c]!==0){ setStatus('처음부터 채워진 칸은 힌트를 사용할 수 없습니다.','error'); return; }
      const correct=solution[r][c]; if(puzzle[r][c]!==correct){ puzzle[r][c]=correct; input.value=String(correct); }
      hintsLeft=Math.max(0,hintsLeft-1); hintBtn.textContent=`힌트 (${hintsLeft})`;
      if(hintsLeft<=0){ setHintMode(false); hintBtn.disabled=true; setStatus('힌트를 모두 사용했습니다.'); }
    }

    /* ===== 게임 수명주기 ===== */
    let originPuzzle = createEmptyGrid();
    function newGame(){
      const difficulty=diffEl.value;
      setStatus('새 퍼즐 생성 중…'); hintBtn.disabled=true;
      setTimeout(()=>{
        const gen=generatePuzzle(difficulty,3000);
        if(!gen){ setStatus('생성 시간이 길어 재시도해주세요.','error'); hintBtn.disabled=false; return; }
        solution=gen.solution; puzzle=deepCopy(gen.puzzle); originPuzzle=deepCopy(gen.puzzle);
        hintsLeft=3; hintBtn.textContent='힌트 (3)'; hintBtn.disabled=false; setHintMode(false);
        buildBoard(); renderBoard(); setStatus('');
        const first=boardEl.querySelector('input:not(:disabled)'); if(first) first.focus();
      },0);
    }

    newBtn.addEventListener('click', newGame);
    diffEl.addEventListener('change', newGame);
    hintBtn.addEventListener('click', ()=>{ if(hintsLeft<=0){ setStatus('힌트를 모두 사용했습니다.'); return; } setHintMode(!hintMode); });
    document.addEventListener('click', (e)=>{ if(!boardEl.contains(e.target)) clearSelection(); });
    window.addEventListener('error', (e)=>{ setStatus('에러: '+(e && e.message? e.message : '알 수 없는 오류'),'error'); });

    /* 초기 실행 */
    buildBoard(); newGame();
  })();
  </script>
</body>
</html>
