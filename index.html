<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>스도쿠 · 블랙 테마 + 랭킹</title>
  <style>
    :root{
      --bg:#000;
      --ui:#fff;
      --cell:#000;
      --num:#BFBFBF;
      --line:#BFBFBF;
      --accent:#9e9e9e;
      --error:#ff4d4f;
      --ok:#52c41a;
      --border:3px;
      --thin:1px;
      --thick:3px;
      --cellpx:40px;
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html{ -webkit-text-size-adjust:100%; }
    html,body{ height:100%; }
    body{
      margin:0; background:var(--bg); color:var(--ui);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", "Apple SD Gothic Neo", "Malgun Gothic", Arial, sans-serif;
      display:flex; align-items:center; justify-content:center;
    }

    .app{ width:min(95vw, 820px); padding:14px; }
    h1{ margin:0 0 8px; font-weight:800; letter-spacing:.2px; }
    .toolbar{ display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin-bottom:10px; }
    .toolbar label{ font-size:13px; opacity:.95; }
    .status{ margin-left:auto; min-height:20px; font-size:13px; opacity:.9; }
    .timer{ font-variant-numeric: tabular-nums; padding:6px 10px; border-radius:10px; border:1px solid #333; background:#111; }

    select, button{
      -webkit-appearance:none; appearance:none;
      background:var(--ui); color:#000;
      border:1px solid #000; border-radius:12px;
      padding:10px 14px; font-size:16px; font-weight:700; cursor:pointer; outline:none;
      min-height:44px;
    }
    button.ghost{ background:#111; color:#fff; border-color:#333; }
    button:disabled{ opacity:.6; cursor:not-allowed; }

    .board-wrap{ position:relative; }
    .board{
      width:min(92vw, 90vmin, 640px);
      background:var(--cell);
      border:var(--border) solid var(--line);
      border-radius:14px;
      display:grid;
      grid-template-columns: repeat(9, 1fr);
      grid-template-rows: repeat(9, 1fr);
      overflow:hidden;
      position:relative;
    }
    /* grid lines moved to per-cell borders for pixel-perfect alignment */


    .cell{ box-sizing:border-box; background:var(--cell); display:flex; align-items:center; justify-content:center; outline:none; position:relative; border-right: var(--thin) solid var(--line); border-bottom: var(--thin) solid var(--line); }
    .cell.selected{ outline:none; }

    input.sudoku{
      width:100%; height:100%;
      display:block; border:none; outline:none; background:transparent;
      text-align:center; -webkit-appearance:none; appearance:none;
      font-weight:800; color:var(--num);
      font-size: calc(var(--cellpx) * 0.60);
      line-height: 1.12;
      padding: 3px 0 3px;
      margin:0;
      caret-color: transparent;
      font-variant-numeric: tabular-nums;
      cursor:pointer;
    }
    input.sudoku:disabled{ cursor:default; color:#E6E6E6; }

    .pad{ display:grid; grid-template-columns: repeat(5, 1fr); gap:8px; margin-top:12px; }
    .pad button{ background:#111; color:#fff; border:1px solid #333; border-radius:12px; padding:12px 0; font-size:18px; font-weight:800; }
    .pad .wide{ grid-column: span 2; }

    .celebrate{ position:absolute; inset:0; pointer-events:none; overflow:hidden; }
    .confetti{ position:absolute; top:-10%; width:8px; height:12px; opacity:0.9; animation: fall 1200ms linear forwards, spin 1200ms linear forwards; }
    @keyframes fall{ to{ transform: translateY(120vh); } }
    @keyframes spin{ from{ transform: rotate(0deg); } to{ transform: rotate(720deg); } }

    /* == Leaderboard Modals == */
    .modal{ position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; align-items:center; justify-content:center; z-index:9999; }
    .modal[aria-hidden="false"]{ display:flex; }
    .modal-card{ width:min(92vw, 520px); background:#0f0f0f; border:1px solid #333; border-radius:16px; padding:16px; color:#fff; }
    .modal-card h2{ margin:0 0 8px; font-size:20px; }
    .modal-card p{ margin:0 0 12px; opacity:.9; }
    .modal-card input{ width:100%; padding:12px 14px; border-radius:12px; border:1px solid #333; background:#111; color:#fff; font-size:16px; }
    .modal-actions{ display:flex; gap:10px; justify-content:flex-end; margin-top:14px; }
    .tabs{ display:flex; gap:8px; margin:8px 0 12px; }
    .tabs button{ background:#111; color:#fff; border:1px solid #333; border-radius:10px; padding:8px 12px; font-weight:700; }
    .tabs button.active{ border-color:#fff; }
    .rank-list{ max-height:50vh; overflow:auto; border:1px solid #222; border-radius:12px; }
    .rank-list table{ width:100%; border-collapse:collapse; }
    .rank-list th, .rank-list td{ padding:10px 12px; border-bottom:1px solid #1a1a1a; font-size:14px; text-align:left; }
    .rank-list tr:nth-child(1) td{ background:#141414; }
  
    /* pixel-perfect inner grid using per-cell borders */
    .cell[c="2"], .cell[c="5"]{ border-right-width: var(--thick); }
    .cell[r="2"], .cell[r="5"]{ border-bottom-width: var(--thick); }
    /* selection highlight pinned to the cell box */
    .cell.selected::after{ content:""; position:absolute; left:0; top:0; right:0; bottom:0; border:3px solid var(--accent); box-sizing:border-box; pointer-events:none; z-index:2; }

  </style>
</head>
<body>
  <div class="app">
    <h1>스도쿠</h1>
    <div class="toolbar">
      <label>난이도
        <select id="difficulty" aria-label="난이도">
          <option value="easy">하 (쉬움)</option>
          <option value="medium" selected>중 (보통)</option>
          <option value="hard">상 (어려움)</option>
        </select>
      </label>
      <button id="newGame">새 게임</button>
      <button id="rankBtn" class="ghost">랭킹</button>
      <button id="checkBtn" class="ghost">오류 체크</button>
      <button id="revealBtn" class="ghost">오류 표시 (3)</button>
      <div class="timer" id="timer">00:00</div>
      <div class="status" id="status" aria-live="polite"></div>
    </div>

    <div class="board-wrap" id="boardWrap">
      <div class="board" id="board" role="grid" aria-label="스도쿠 보드"></div>
      <div class="celebrate" id="celebrate"></div>
    </div>

    <!-- 이름 입력 모달 -->
    <div id="nameModal" class="modal" aria-hidden="true">
      <div class="modal-card">
        <h2>이름 입력</h2>
        <p>기록을 저장하려면 이름을 적어주세요.</p>
        <input id="playerName" type="text" maxlength="20" placeholder="이름" />
        <div class="modal-actions">
          <button id="saveScoreBtn">저장</button>
          <button id="cancelScoreBtn" class="ghost">취소</button>
        </div>
      </div>
    </div>

    <!-- 랭킹 모달 -->
    <div id="rankModal" class="modal" aria-hidden="true">
      <div class="modal-card">
        <h2>랭킹</h2>
        <div id="rankTabs" class="tabs">
          <button data-diff="easy">하</button>
          <button data-diff="medium" class="active">중</button>
          <button data-diff="hard">상</button>
        </div>
        <div id="rankList" class="rank-list"></div>
        <div class="modal-actions">
          <button id="closeRankBtn">닫기</button>
        </div>
      </div>
    </div>

    <!-- 숫자 패드 -->
    <div class="pad" id="numpad" aria-label="숫자패드">
      <button data-val="1">1</button><button data-val="2">2</button><button data-val="3">3</button><button data-val="4">4</button><button data-val="5">5</button>
      <button data-val="6">6</button><button data-val="7">7</button><button data-val="8">8</button><button data-val="9">9</button>
      <button data-act="erase" class="wide">지우기</button><button id="padHintBtn" data-act="hint" class="wide">힌트 사용 (3)</button>
    </div>
  </div>

  <script>
  (function(){
    'use strict';

    const ROWS=9, COLS=9, CELLS=ROWS*COLS;
    const boardEl=document.getElementById('board');
    const diffEl=document.getElementById('difficulty');
    const newBtn=document.getElementById('newGame');
    const statusEl=document.getElementById('status');
    const checkBtn=document.getElementById('checkBtn');
    const revealBtn=document.getElementById('revealBtn');
    const celebrateEl=document.getElementById('celebrate');
    const timerEl=document.getElementById('timer');
    const padEl=document.getElementById('numpad');
    const padHintBtn=document.getElementById('padHintBtn');
    const rankBtn=document.getElementById('rankBtn');

    const nameModal=document.getElementById('nameModal');
    const playerName=document.getElementById('playerName');
    const saveScoreBtn=document.getElementById('saveScoreBtn');
    const cancelScoreBtn=document.getElementById('cancelScoreBtn');

    const rankModal=document.getElementById('rankModal');
    const rankTabs=document.getElementById('rankTabs');
    const rankList=document.getElementById('rankList');
    const closeRankBtn=document.getElementById('closeRankBtn');

    let solution=createEmpty(), puzzle=createEmpty(), origin=createEmpty();
    let selectedInput=null, hintsLeft=3, revealLeft=3;
    let timerId=null, startTs=null;

    const DIFFICULTY_CLUES={ easy:[36,45], medium:[32,35], hard:[28,31] };

    function layoutBoard(){
      const cs = getComputedStyle(boardEl);
      const border = parseFloat(cs.borderTopWidth) || 3;
      // current rendered width from CSS (may not be a multiple of 9)
      const avail = Math.round(boardEl.getBoundingClientRect().width);
      // choose cell size s so that inner area = 9*s and board = 9*s + 2*border
      let s = Math.floor((avail - border*2) / 9);
      if (s < 22) s = 22;
      const outer = s*9 + border*2;
      // snap the board to the exact pixel size so inner grid aligns to outer border
      boardEl.style.width  = outer + 'px';
      boardEl.style.height = outer + 'px';
      boardEl.style.gridTemplateColumns = `repeat(9, ${s}px)`;
      boardEl.style.gridTemplateRows    = `repeat(9, ${s}px)`;
      boardEl.style.setProperty('--cellpx', s+'px');
    }
    const ro=new ResizeObserver(()=> layoutBoard());
    ro.observe(boardEl);
    window.addEventListener('orientationchange', ()=> setTimeout(layoutBoard, 120));
    window.addEventListener('pageshow', ()=> setTimeout(layoutBoard, 0));

    function setStatus(msg, cls){
      statusEl.textContent=msg||'';
      statusEl.className='status';
      if(cls) statusEl.classList.add(cls);
    }
    function createEmpty(){ const g=[]; for(let r=0;r<ROWS;r++){ const row=[]; for(let c=0;c<COLS;c++) row.push(0); g.push(row);} return g; }
    function deepCopy(g){ const out=[]; for(let r=0;r<ROWS;r++){ const row=[]; for(let c=0;c<COLS;c++) row.push(g[r][c]); out.push(row);} return out; }
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]];} return a; }
    function randInt(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }

    function getCandidates(b,r,c){
      if(b[r][c]!==0) return [];
      const cand=[]; for(let n=1;n<=9;n++){
        let ok=true;
        for(let i=0;i<COLS;i++) if(b[r][i]===n) { ok=false; break; }
        if(ok) for(let i=0;i<ROWS;i++) if(b[i][c]===n){ ok=false; break; }
        if(ok){
          const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
          for(let i=0;i<3;i++) for(let j=0;j<3;j++) if(b[br+i][bc+j]===n){ ok=false; break; }
        }
        if(ok) cand.push(n);
      }
      return cand;
    }
    function findBestCell(b){
      let best=null, bestCount=10;
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){
        if(b[r][c]===0){
          const cand=getCandidates(b,r,c), k=cand.length;
          if(k===0) return {r,c,cand};
          if(k<bestCount){ best={r,c,cand}; bestCount=k; if(k===1) return best; }
        }
      }
      return best;
    }
    function fillBoardRandom(b){
      const cell=findBestCell(b);
      if(!cell) return true;
      const {r,c,cand}=cell;
      if(cand.length===0) return false;
      shuffle(cand);
      for(const n of cand){ b[r][c]=n; if(fillBoardRandom(b)) return true; b[r][c]=0; }
      return false;
    }
    function countSolutions(b, limit=2){
      let count=0;
      (function backtrack(){
        if(count>=limit) return;
        const cell=findBestCell(b);
        if(!cell){ count++; return; }
        const {r,c,cand}=cell;
        if(cand.length===0) return;
        for(const n of cand){ b[r][c]=n; backtrack(); b[r][c]=0; if(count>=limit) return; }
      })();
      return count;
    }
    function generatePuzzle(diff, timeoutMs=2500){
      const deadline=(performance&&performance.now?performance.now():Date.now())+timeoutMs;
      while((performance&&performance.now?performance.now():Date.now())<deadline){
        const sol=createEmpty(); if(!fillBoardRandom(sol)) continue;
        const clueRange={ easy:[36,45], medium:[32,35], hard:[28,31] }[diff] || [32,35];
        const target=randInt(clueRange[0], clueRange[1]);
        const puz=deepCopy(sol);
        let clues=ROWS*COLS;
        const order=shuffle([...Array(CELLS).keys()]);
        let ok=true;
        for(const idx of order){
          if(clues<=target) break;
          const r=Math.floor(idx/COLS), c=idx%COLS;
          if(puz[r][c]===0) continue;
          const keep=puz[r][c]; puz[r][c]=0;
          const tmp=deepCopy(puz);
          if(countSolutions(tmp,2)!==1){ puz[r][c]=keep; } else { clues--; }
          if((performance&&performance.now?performance.now():Date.now())>deadline){ ok=false; break; }
        }
        if(ok) return {solution:sol, puzzle:puz};
      }
      return null;
    }

    function listConflicts(b){
      const bad=new Set();
      for(let r=0;r<ROWS;r++){
        const seen={};
        for(let c=0;c<COLS;c++){
          const v=b[r][c]; if(!v) continue;
          const k='R'+r+'#'+v;
          if(seen[k]!==undefined){ bad.add(r+','+c); bad.add(r+','+seen[k]); }
          else seen[k]=c;
        }
      }
      for(let c=0;c<COLS;c++){
        const seen={};
        for(let r=0;r<ROWS;r++){
          const v=b[r][c]; if(!v) continue;
          const k='C'+c+'#'+v;
          if(seen[k]!==undefined){ bad.add(r+','+c); bad.add(seen[k]+','+c); }
          else seen[k]=r;
        }
      }
      for(let br=0;br<3;br++) for(let bc=0;bc<3;bc++){
        const seen={};
        for(let i=0;i<3;i++) for(let j=0;j<3;j++){
          const r=br*3+i, c=bc*3+j, v=b[r][c]; if(!v) continue;
          const k='B'+br+bc+'#'+v;
          if(seen[k]){ bad.add(r+','+c); bad.add(seen[k].r+','+seen[k].c); }
          else seen[k]={r,c};
        }
      }
      return bad;
    }
    function countConflicts(b){ return listConflicts(b).size; }
    function revealConflictsOnce(){
      const bad=listConflicts(puzzle);
      [...boardEl.children].forEach((cell,i)=>{
        const r=Math.floor(i/COLS), c=i%COLS;
        cell.style.background = bad.has(r+','+c) ? '#1a0002' : 'var(--cell)';
      });
      setTimeout(()=>{
        [...boardEl.children].forEach(cell=> cell.style.background='var(--cell)');
      }, 1400);
    }

    function ensureSelection(){
      if(selectedInput && !selectedInput.disabled) return selectedInput;
      const next=boardEl.querySelector('input:not(:disabled)');
      if(next){ next.focus({preventScroll:true}); selectedInput=next; next.parentElement.classList.add('selected'); }
      return next;
    }
    padEl.addEventListener('click', (e)=>{
      const btn=e.target.closest('button'); if(!btn) return;
      const target=ensureSelection(); if(!target) return;
      const r=Number(target.parentElement.getAttribute('r'));
      const c=Number(target.parentElement.getAttribute('c'));
      if(btn.dataset.val){
        const v=Number(btn.dataset.val);
        target.value=String(v); puzzle[r][c]=v;
        afterUserInput(r,c);
      }else if(btn.dataset.act==='erase'){
        target.value=''; puzzle[r][c]=0; afterUserInput(r,c);
      }else if(btn.dataset.act==='hint'){
        if(hintsLeft<=0){ setStatus('힌트를 모두 사용했습니다.'); padHintBtn.disabled=true; return; }
        if(origin[r][c]!==0){ setStatus('처음부터 채워진 칸은 힌트를 사용할 수 없습니다.','error'); return; }
        target.value=String(solution[r][c]); puzzle[r][c]=solution[r][c];
        hintsLeft--; updateHintLabel();
        afterUserInput(r,c);
      }
    });
    function updateHintLabel(){
      padHintBtn.textContent = '힌트 사용 ('+hintsLeft+')';
      padHintBtn.disabled = hintsLeft<=0;
    }

    function afterUserInput(r,c){ checkSolved(); }

    function startTimer(){
      stopTimer();
      startTs=Date.now();
      timerId=setInterval(()=>{
        const sec=Math.floor((Date.now()-startTs)/1000);
        timerEl.textContent=fmt(sec);
      }, 250);
    }
    function stopTimer(){ if(timerId){ clearInterval(timerId); timerId=null; } }
    function fmt(sec){ const m=Math.floor(sec/60), s=sec%60; return String(m).padStart(2,'0')+':'+String(s).padStart(2,'0'); }

    function celebrate(){
      celebrateEl.innerHTML='';
      const colors=['#ff5252','#ffca28','#66bb6a','#42a5f5','#ab47bc','#ef5350'];
      const W=boardEl.clientWidth;
      for(let i=0;i<80;i++){
        const d=document.createElement('div');
        d.className='confetti';
        d.style.left=(Math.random()*W)+'px';
        d.style.background=colors[i%colors.length];
        d.style.animationDelay=(Math.random()*0.5)+'s';
        d.style.transform='translateY(-10vh)';
        celebrateEl.appendChild(d);
      }
      setTimeout(()=> celebrateEl.innerHTML='', 1600);
    }

    function buildBoard(){
      boardEl.innerHTML='';
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const cell=document.createElement('div');
          cell.className='cell';
          cell.setAttribute('r', r);
          cell.setAttribute('c', c);
          const input=document.createElement('input');
          input.type='text';
          input.readOnly = true;
          input.inputMode = 'none';
          input.pattern='[0-9]*';
          input.maxLength=1;
          input.className='sudoku';
          input.addEventListener('focus', ()=> selectCell(cell, input));
          input.addEventListener('click', ()=> selectCell(cell, input));
          input.addEventListener('keydown', (e)=>{ e.preventDefault(); });
          cell.addEventListener('click', ()=> selectCell(cell, input));
          cell.appendChild(input);
          boardEl.appendChild(cell);
        }
      }
      layoutBoard();
    }
    function renderBoard(){
      for(let r=0;r<ROWS;r++){
        for(let c=0;c<COLS;c++){
          const idx=r*COLS+c;
          const input=boardEl.children[idx].querySelector('input');
          const val=puzzle[r][c];
          const given=origin[r][c]!==0;
          input.value=val?String(val):'';
          input.disabled=given;
        }
      }
      layoutBoard();
    }
    function clearSelection(){
      const prev=document.querySelector('.cell.selected');
      if(prev) prev.classList.remove('selected');
    }
    function selectCell(cell, input){
      if(input.disabled) return;
      clearSelection(); cell.classList.add('selected'); selectedInput=input;
      input.focus({preventScroll:true});
    }

    function checkSolved(){
      for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++){ if(puzzle[r][c]===0) return false; }
      const bad=listConflicts(puzzle);
      if(bad.size===0){
        stopTimer();
        setStatus('클리어! 기록: '+timerEl.textContent, 'ok');
        celebrate();
        openNameModal();
        return true;
      }
      return false;
    }

    function newGame(){
      setStatus('새 퍼즐 생성 중…');
      revealLeft=3; revealBtn.textContent='오류 표시 (3)';
      hintsLeft=3; updateHintLabel();
      setTimeout(()=>{
        const gen=generatePuzzle(diffEl.value, 3000);
        if(!gen){ setStatus('생성 시간이 길어 재시도해주세요.','error'); return; }
        solution=gen.solution;
        puzzle=deepCopy(gen.puzzle);
        origin=deepCopy(gen.puzzle);
        buildBoard();
        renderBoard();
        setStatus('');
        const first=boardEl.querySelector('input:not(:disabled)'); if(first) { selectCell(first.parentElement, first); }
        startTimer();
      }, 0);
    }

    /* ===== 랭킹(로컬 저장소) ===== */
    function storageKey(diff){ return 'sudoku_rank_'+diff; }
    function loadRanks(diff){
      try{ return JSON.parse(localStorage.getItem(storageKey(diff))||'[]'); }
      catch(_){ return []; }
    }
    function saveRanks(diff, arr){
      try{ localStorage.setItem(storageKey(diff), JSON.stringify(arr)); }catch(_){}
    }
    function recordScore(diff, seconds, name){
      const rec = { name: String(name||'Player').slice(0,20), sec: Number(seconds)||0, at: Date.now() };
      const list = loadRanks(diff);
      list.push(rec);
      list.sort((a,b)=> a.sec - b.sec || a.at - b.at);
      saveRanks(diff, list.slice(0,50));
    }
    function fmtTime(sec){ const m=Math.floor(sec/60), s=sec%60; return String(m).padStart(2,'0')+':'+String(s).padStart(2,'0'); }
    function escapeHtml(str){
      return String(str).replace(/[&<>\"']/g, function(s){
        switch(s){
          case '&': return '&amp;';
          case '<': return '&lt;';
          case '>': return '&gt;';
          case '\"': return '&quot;';
          case "'": return '&#39;';
          default: return s;
        }
      });
    }

    function openNameModal(){
      nameModal.setAttribute('aria-hidden','false');
      playerName.value='';
      setTimeout(()=> playerName.focus(), 10);
    }
    function closeNameModal(){ nameModal.setAttribute('aria-hidden','true'); }

    function renderRanks(diff){
      const data = loadRanks(diff);
      let h = '<table><thead><tr><th>#</th><th>이름</th><th>기록</th><th>일자</th></tr></thead><tbody>';
      if(data.length===0){
        h += '<tr><td colspan="4" style="text-align:center; opacity:.8; padding:14px;">기록이 없습니다.</td></tr>';
      }else{
        data.slice(0,50).forEach((r,i)=>{
          const d = new Date(r.at);
          const date = d.getFullYear()+'-'+String(d.getMonth()+1).padStart(2,'0')+'-'+String(d.getDate()).padStart(2,'0');
          h += '<tr><td>'+ (i+1) +'</td><td>'+ escapeHtml(r.name) +'</td><td>'+ fmtTime(r.sec) +'</td><td>'+ date +'</td></tr>';
        });
      }
      h += '</tbody></table>';
      rankList.innerHTML = h;
    }
    function openRankModal(initialDiff){
      Array.from(rankTabs.querySelectorAll('button')).forEach(btn=>{
        btn.classList.toggle('active', btn.dataset.diff===initialDiff);
      });
      renderRanks(initialDiff);
      rankModal.setAttribute('aria-hidden','false');
    }
    function closeRankModal(){ rankModal.setAttribute('aria-hidden','true'); }

    rankBtn && rankBtn.addEventListener('click', ()=> openRankModal(diffEl.value));
    closeRankBtn && closeRankBtn.addEventListener('click', closeRankModal);
    rankTabs && rankTabs.addEventListener('click', (e)=>{
      const b=e.target.closest('button'); if(!b) return;
      Array.from(rankTabs.querySelectorAll('button')).forEach(x=> x.classList.remove('active'));
      b.classList.add('active');
      renderRanks(b.dataset.diff);
    });
    saveScoreBtn && saveScoreBtn.addEventListener('click', ()=>{
      const name = playerName.value.trim() || 'Player';
      const sec  = Math.floor((Date.now()-startTs)/1000);
      const diff = diffEl.value;
      recordScore(diff, sec, name);
      closeNameModal();
      openRankModal(diff);
    });
    cancelScoreBtn && cancelScoreBtn.addEventListener('click', closeNameModal);

    newBtn.addEventListener('click', newGame);
    diffEl.addEventListener('change', newGame);
    checkBtn.addEventListener('click', ()=>{
      const n=countConflicts(puzzle);
      setStatus(n>0? ('오류 '+n+'개가 검출되었습니다.'): '오류 없음', n>0?'error':'ok');
    });
    revealBtn.addEventListener('click', ()=>{
      if(revealLeft<=0){ setStatus('이 기능은 게임당 3회만 사용 가능합니다.'); return; }
      revealLeft--; revealBtn.textContent='오류 표시 ('+revealLeft+')';
      revealConflictsOnce();
    });
    window.addEventListener('error', (e)=>{
      const msg = '에러: '+(e && e.message ? e.message : '알 수 없는 오류');
      console.error(e?.error || e);
      setStatus(msg, 'error');
    });

    // 초기 실행
    newGame();
  })();
  </script>
</body>
</html>
